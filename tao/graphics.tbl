// ****************************************************************************
//  graphics.tbl                                                    Tao project
// ****************************************************************************
//
//   File Description:
//
//     List of basic entry points used to create Tao documents
//
//
//
//
//
//
//
//
// ****************************************************************************
// This software is property of Taodyne SAS - Confidential
// Ce logiciel est la propriété de Taodyne SAS - Confidentiel
//  (C) 1992-2010 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2010 Lionel Schaffhauser <lionel@taodyne.com>
//  (C) 2010 Catherine Burvelle <catherine@todyne.com>
//  (C) 2010 Taodyne SAS
// ****************************************************************************

// ============================================================================
//
// Getting attributes
//
// ============================================================================

PREFIX(WindowSize, tree, "window_size",
       PARM(w, integer, "Width of the window.")
       PARM(h, integer, "Height of the window."),
       RTAO(windowSize(self, w, h)),
       GROUP(page)
       SYNOPSIS("Resize the window to the specified width and height."))

PREFIX(ShowHide, tree, "show",
       PARM(amount, real, "Amount of global transparency"),
       RTAO(visibility(self, amount)),
       GROUP(page)
       SYNOPSIS("Show or hide elements"))

PREFIX(Page, text, "page",
       PARM(name, text, "Name of the page.")
       PARM(body, code, "Content of the page."),
       RTAO(page(context, name, body)),
       GROUP(page)
       SYNOPSIS("Create a page in a document.")
       DESCRIPTION("Create a new page in the document with the given name, "
                   "or add to the content of a previously created page. "
                   "The body contents will be evaluated only when the page "
                   "is being displayed. The order of pages in the document "
                   "is the order of page creation.")
       RETURNS(text, "The name of the previous page"))
PREFIX(PageLink, text,  "page_link",
       PARM(key, text, "Key used to change pages")
       PARM(name, text, "The name of the page to link"),
       RTAO(pageLink(self, key, name)),
       GROUP(page)
       SYNOPSIS("Link other pages to the current page")
       DESCRIPTION("Links the key with the named page.")
       RETURNS(text, "The name of the page previously linked to this key."))
PREFIX(GotoPage,  text,  "goto_page",
       PARM(p, text, ""),
       RTAO(gotoPage(self, p)),
       GROUP(page)
       SYNOPSIS("Directly go to the given page.")
       DESCRIPTION("Directly go to the given page.")
       RETURNS(text, "The name of the previously shown page."))

PREFIX(Transition, tree, "transition",
       PARM(duration, real, "Duration of the transition")
       PARM(body, code, "Code evaluating the transition"),
       RTAO(transition(context, self, duration, body)),
       GROUP(page)
       SYNOPSIS("Implement a transition when exiting from current page"))
PREFIX(TransitionTime, real, "transition_time", ,
       RTAO(transitionTime(self)),
       GROUP(page)
       SYNOPSIS("Return the time since we began current transition"))
PREFIX(TransitionDuration, real, "transition_duration", ,
       RTAO(transitionDuration(self)),
       GROUP(page)
       SYNOPSIS("Return the duration of current transition"))
PREFIX(TransitionRatio, real, "transition_ratio", ,
       RTAO(transitionRatio(self)),
       GROUP(page)
       SYNOPSIS("Return the ratio of execution for current transition"))
PREFIX(TransitionCurrentPage, tree, "transition_current_page",,
       RTAO(transitionCurrentPage(context, self)),
       GROUP(page)
       SYNOPSIS("Evaluate the current page in a transition"))
PREFIX(TransitionNextPage, tree, "transition_next_page",,
       RTAO(transitionNextPage(context, self)),
       GROUP(page)
       SYNOPSIS("Evaluate the next page in a transition"))

PREFIX(PageLabel,    text,      "page_label", , RTAO(pageLabel(self)),
       GROUP(page)
       SYNOPSIS("The current page name.")
       DESCRIPTION("Return the current page name")
       RETURNS(text, "Return the label of the current page"))
PREFIX(PageId,       integer,   "page_number", , RTAO(pageNumber(self)),
       GROUP(page)
       SYNOPSIS("The current page number")
       DESCRIPTION("Return the number of the current page")
       RETURNS(integer, "Return the number of the current page"))
PREFIX(PageCount,    integer,   "page_count", , RTAO(pageCount(self)),
       GROUP(page)
       SYNOPSIS("The number of page.")
       DESCRIPTION("Return the number of pages in the current document")
       RETURNS(integer, "The number of pages in the current document"))
PREFIX(PageName,    text,   "page_name",
       PARM(n, integer, "Index of page, starting at 0"),
       RTAO(pageNameAtIndex(self, n)),
       GROUP(page)
       SYNOPSIS("The name of the nth page.")
       DESCRIPTION("Return the name of a page given its index")
       RETURNS(text, "The name of the nth page"))

PREFIX(PageWidth,    real,      "page_width", , RTAO(pageWidth(self)),
       GROUP(page)
       SYNOPSIS("Return the width of pages")
       DESCRIPTION("Return the width of pages")
       RETURNS(real, "Return the width of pages"))
PREFIX(PageHeight,   real,      "page_height", , RTAO(pageHeight(self)),
       GROUP(page)
       SYNOPSIS("Return the height of pages")
       DESCRIPTION("Return the height of pages")
       RETURNS(real, "Return the height of pages"))

PREFIX(PagePrintTime,  real,  "page_print_time",
       PARM(t, real, ),
       RTAO(pageSetPrintTime(self, t)),
       GROUP(page)
       SYNOPSIS("Set the freeze time used when printing.")
       DESCRIPTION("Set the time used when printing pages")
       RETURNS(real, "Previous time used for printing"))
PREFIX(PageThumbnail, tree, "page_thumbnail",
       PARM(s, real, "Scaling of the thumbnail")
       PARM(i, real, "Refresh interval")
       PARM(p, text, "Page name"),
       RTAO(thumbnail(context, self, s, i, p)),
       GROUP(page)
       SYNOPSIS("Generate a page thumbnail as a texture"))
PREFIX(OffLineRendering, boolean, "offline_rendering", , RTAO(offlineRendering(self)),
       GROUP(page)
       SYNOPSIS("Return true if we are currently rendering to file")
       DESCRIPTION("")
       RETURNS(boolean, "Return the offline rendering status"))

PREFIX(FrameWidth,   real,      "frame_width", , RTAO(frameWidth(self)),
       GROUP(frame)
       SYNOPSIS("Return the width of the current layout frame")
       DESCRIPTION("Return the width of the current layout frame")
       RETURNS(real, "Return the width of the current layout frame"))
PREFIX(FrameHeight,  real,      "frame_height", , RTAO(frameHeight(self)),
       GROUP(frame)
       SYNOPSIS("Return the height of the current layout frame")
       DESCRIPTION("Return the height of the current layout frame")
       RETURNS(real, "Return the height of the current layout frame"))
PREFIX(FrameDepth,   real,      "frame_depth", , RTAO(frameDepth(self)),
       GROUP(frame)
       SYNOPSIS("Return the depth of the current layout frame")
       DESCRIPTION("Return the depth of the current layout frame")
       RETURNS(real, "Return the depth of the current layout frame"))
PREFIX(WindowWidth,  real,      "window_width", ,
       RTAO(windowWidth(self)),
       GROUP(window)
       SYNOPSIS("Return the width of the window in which we display")
       DESCRIPTION("Return the width of the window in which we display")
       RETURNS(real, "Return the width of the window in which we display"))
PREFIX(WindowHeight, real,      "window_height", , RTAO(windowHeight(self)),
       GROUP(window)
       SYNOPSIS("Return the height of window in which we display")
       DESCRIPTION("Return the height of window in which we display")
       RETURNS(real, "Return the height of window in which we display"))
PREFIX(TimeSeconds, integer,  "seconds", PARM(t, real, ), RTAO(seconds(self, t)),
       GROUP(time) SYNOPSIS("Extract seconds from timestamp"))
PREFIX(TimeMinutes, integer,  "minutes", PARM(t, real, ), RTAO(minutes(self, t)),
       GROUP(time) SYNOPSIS("Extract minutes (local time) from timestamp"))
PREFIX(TimeHours,   integer,  "hours", PARM(t, real, ), RTAO(hours(self, t)),
       GROUP(time) SYNOPSIS("Extract hours (local time) from timestamp"))
PREFIX(TimeDay,     integer,  "day", PARM(t, real, ), RTAO(day(self, t)),
       GROUP(time) SYNOPSIS("Extract day (1-31) from timestamp"))
PREFIX(TimeWeekDay, integer,  "week_day", PARM(t, real, ), RTAO(weekDay(self, t)),
       GROUP(time) SYNOPSIS("Extract week day (1-7) from timestamp"))
PREFIX(TimeYearDay, integer,  "year_day", PARM(t, real, ), RTAO(yearDay(self, t)),
       GROUP(time) SYNOPSIS("Extract year day (1-365) from timestamp"))
PREFIX(TimeMonth,   integer,  "month", PARM(t, real, ), RTAO(month(self, t)),
       GROUP(time) SYNOPSIS("Extract month from timestamp"))
PREFIX(TimeYear, integer,  "year", PARM(t, real, ), RTAO(year(self, t)),
       GROUP(time) SYNOPSIS("Extract year from timestamp"))
PREFIX(Seconds, integer, "seconds" ,, RTAO(seconds(self, -1.0)),
       GROUP(time) SYNOPSIS("Return seconds of current time"))
PREFIX(Minutes, integer, "minutes" ,, RTAO(minutes(self, -1.0)),
       GROUP(time) SYNOPSIS("Return minutes of current time"))
PREFIX(Hours,   integer, "hours"   ,, RTAO(hours(self, -1.0)),
       GROUP(time) SYNOPSIS("Return hours of current time"))
PREFIX(Day,     integer, "day"     ,, RTAO(day(self, -1.0)),
       GROUP(time) SYNOPSIS("Return current day of month"))
PREFIX(WeekDay, integer, "week_day",, RTAO(weekDay(self, -1.0)),
       GROUP(time) SYNOPSIS("Return current day of week"))
PREFIX(YearDay, integer, "year_day",, RTAO(yearDay(self, -1.0)),
       GROUP(time) SYNOPSIS("Return current day of year"))
PREFIX(Month,   integer, "month"   ,, RTAO(month(self, -1.0)),
       GROUP(time) SYNOPSIS("Return current month"))
PREFIX(Year,    integer, "year"    ,, RTAO(year(self, -1.0)),
       GROUP(time) SYNOPSIS("Return current year"))
PREFIX(DaySeconds,   real,      "time", , RTAO(time(self)),
       GROUP(time)
       SYNOPSIS("Return a fractional time, including milliseconds")
       DESCRIPTION("Returns the current document's time or the time at wich the document was frozen.")
       RETURNS(real, "Return a fractional time, including milliseconds"))
PREFIX(PageTime,  real,      "page_time", , RTAO(pageTime(self)),
       GROUP(time)
       SYNOPSIS("Returns the number of seconds since page was shown.]")
       DESCRIPTION("Returns the number of seconds since the page was shown. "
                   "The precision is at least one millisecond. "
                   "The time value is frozen when animations are disabled.")
       RETURNS(real, "Return a fractional time, including milliseconds"))
PREFIX(PageSeconds,  integer,      "page_seconds", , RTAO(pageSeconds(self)),
       GROUP(time)
       SYNOPSIS("Returns the number of seconds since page was shown.]")
       DESCRIPTION("Returns the number of seconds since the page was shown. "
                   "The precision is at least one millisecond. "
                   "The time value is frozen when animations are disabled.")
       RETURNS(real, "Return a fractional time, including milliseconds"))
PREFIX(After, real, "after",
       PARM(interval, real, "Interval in seconds")
       PARM(body, code, "Code to evaluate."),
       RTAO(after(context, interval, body)),
       GROUP(time)
       SYNOPSIS("Execute some code after a delay")
       DESCRIPTION("Execute the given code after the specified amount of time.")
       RETURNS(real, "The real elapsed time."))
PREFIX(Every, real, "every",
       PARM(interval, real, "Repeat interval")
       PARM(duty, real, "Duty cycle")
       PARM(body, code, "Code to evaluate"),
       RTAO(every(context, interval, duty, body)),
       GROUP(time)
       SYNOPSIS("Execute some code at regular intervals")
       DESCRIPTION("Execute the specified code at regular intervals. "
                   "The interval is specified in seconds, with a precision "
                   "of one millisecond. The duty cycle is the fraction of "
                   "the time interval during which the code executes."))
PREFIX(Every50Pct, real, "every",
       PARM(interval, real, "Repeat interval")
       PARM(body, code, "Code to evaluate"),
       RTAO(every(context, interval, 0.5, body)),
       GROUP(time)
       SYNOPSIS("Execute some code at regular intervals")
       DESCRIPTION("Execute the specified code at regular intervals. "
                   "The interval is specified in seconds, with a precision "
                   "of one millisecond. The specified code evaluates for "
                   "approximately 50% of the time."))

PREFIX(MouseX,  real,  "mouse_x", , RTAO(mouseX(self)),
       GROUP(mouse)
       SYNOPSIS("Mouse x-coordinate")
       DESCRIPTION("Mouse x-coordinate")
       RETURNS(real, "Return the position of the mouse"))
PREFIX(MouseY,  real,  "mouse_y", , RTAO(mouseY(self)),
       GROUP(mouse)
       SYNOPSIS("Mouse y-coordinate")
       DESCRIPTION("Mouse y-coordinate")
       RETURNS(real, "Return the position of the mouse"))
PREFIX(ScreenMouseX, integer, "screen_mouse_x", , RTAO(screenMouseX(self)), )
PREFIX(ScreenMouseY, integer, "screen_mouse_y", , RTAO(screenMouseY(self)), )
PREFIX(MouseButtons,  integer,  "mouse_buttons", , RTAO(mouseButtons(self)),
       GROUP(mouse)
       SYNOPSIS("Return the buttons of the last mouse event")
       DESCRIPTION("Return the buttons of the last mouse event. "
                   "It is an OR combination of following values:\n"
                   "0x00000000 The button state does not refer to any button\n"
                   "0x00000001 The primary button is pressed. "
                   "The primary button is generally the leftmost one."
                   "0x00000002 The secondary button is pressed. "
                   "The secondary button is generally the rightmost one."
                   "0x00000004 The third mouse button is pressed. "
                   "THis is generally the middle button."
                   "0x00000008	(X11 only) First X button.\n"
                   "0x00000010  (X11 only) Second X button.\n")
       RETURNS(integer, "Button state of the last mouse event"))
PREFIX(TaoFeatureAvailable,  boolean,  "is_available",
       PARM(name, symbol, "The name of the feature to test"),
       RTAO(taoFeatureAvailable(self, name)),
       GROUP(misc)
       SYNOPSIS("Check if a functionality is available")
       DESCRIPTION("Check if a specific Tao feature is available with the current version of the program")
       RETURNS( boolean, "True if the feature is compiled in, false otherwise.") )
PREFIX(GLVersion,  text,  "GL_version",,
       RTAO(GLVersion(self)),
       GROUP(misc)
       SYNOPSIS("")
       DESCRIPTION("Determine current supported version")
       RETURNS( text, "name of current OpenGL version") )
PREFIX(isGLExtensionAvailable,  boolean,  "is_ext_available",
       PARM(name, text, "The name of the extention to test"),
       RTAO(isGLExtensionAvailable(self, name)),
       GROUP(misc)
       SYNOPSIS("Check if an OpenGL extension is available")
       DESCRIPTION("Check if a specific OpenGL extension is available with the current version of the program")
       RETURNS( boolean, "True if the extension is available, false otherwise.") )
PREFIX(HasDisplayMode,  boolean,  "has_display_mode",
       PARM(name, symbol, "The name of the display mode to test"),
       RTAO(hasDisplayMode(self, name)),
       GROUP(misc)
       SYNOPSIS("Check if a display mode is available")
       DESCRIPTION("Check if a specific display mode is available and can be used")
       RETURNS(boolean, "True if the mode is available, false otherwise.") )
PREFIX(GetWorldZ,  real,  "depth_at",
       PARM(x, real, "x-coordinates on the screen")
       PARM(y, real, "y-coordinates on the screen"),
       RTAO(getWorldZ(self, x, y)),
       GROUP(misc)
       SYNOPSIS("Get Z depth at given coordinates")
       DESCRIPTION("Get Z depth at given coordinates")
       RETURNS(infix, "Z depth at given coordinates.") )
PREFIX(GetWorldCoordinates,  real,  "world_coordinates",
       PARM(x, real, "x-coordinates on the screen")
       PARM(y, real, "y-coordinates on the screen")
       PARM(wx, real, "x-coordinates on the screen")
       PARM(wy, real, "y-coordinates on the screen")
       PARM(wz, real, "z-coordinates on the screen"),
       RTAO(getWorldCoordinates(self, x, y, wx, wy, wz)),
       GROUP(misc)
       SYNOPSIS("Get Z depth at given coordinates")
       DESCRIPTION("Get Z depth at given coordinates")
       RETURNS(infix, "Z depth at given coordinates.") )
PREFIX(HasDisplayModeText,  boolean,  "has_display_mode",
       PARM(name, text, "The name of the display mode to test"),
       RTAO(hasDisplayModeText(self, name)),
       GROUP(misc)
       SYNOPSIS("Check if a display mode is available")
       DESCRIPTION("Check if a specific display mode is available and can be used")
       RETURNS(boolean, "True if the mode is available, false otherwise.") )
PREFIX(ScreenShot,  boolean,  "screenshot",
       PARM(name, text, "The name of the file to save to")
       PARM(with_alpha, boolean, "True to save the alpha channel"),
       RTAO(screenShot(self, name, with_alpha)),
       GROUP(misc)
       SYNOPSIS("Save a snapshot of the draw area into a file."))



// ============================================================================
//
// Preserving attributes
//
// ============================================================================

PREFIX(Locally,  tree,  "locally",
       PARM(t, code, "The code to execute in a local context"),
       RTAO(locally(context, self, t)),
       GROUP(code)
       SYNOPSIS("Make a local context")
       DESCRIPTION("Evaluate the child tree while preserving the current state")
       RETURNS(tree, "The result of the child execution."))
PREFIX(Shape,    tree,  "shape",
       PARM(t, code, "The code of the shape."),
       RTAO(shape(context, self, t)),
       GROUP(code:graph)
       SYNOPSIS("Make the shape selectable")
       DESCRIPTION("Evaluate the child and mark the current shape. Make the shape sensible to mosue events like selection, motion, rotation...")
       RETURNS(tree, "The result of the child execution."))
PREFIX(Widget,   tree,  "active_widget",
       PARM(t,code, "The code that represent the widget."),
       RTAO(activeWidget(context, self,t)),
       GROUP(code:graph:widget)
       SYNOPSIS("Make the widget clickable")
       DESCRIPTION("Create a context for active widgets, e.g. buttons")
       RETURNS(tree, "The result of the child execution."))
PREFIX(Anchor,   tree,  "anchor",
       PARM(t, code, "The code that represent the shapes to be anchored."),
       RTAO(anchor(context, self, t)),
       GROUP(graph)
       SYNOPSIS("")
       DESCRIPTION("Anchor a set of shapes to the current position")
       RETURNS(tree, "The result of the child execution."))
PREFIX(StereoViewpoints,  tree,  "stereo_viewpoints",
       PARM(e, integer, "The bit mask for viewpoints")
       PARM(t, code, "The code to execute in a local context"),
       RTAO(stereoViewpoints(context, self, e, t)),
       GROUP(code)
       SYNOPSIS("Make a local context")
       DESCRIPTION("Evaluate the child tree while preserving the current state")
       RETURNS(tree, "The result of the child execution."))
PREFIX(GetStereoViewpoints,  integer,  "stereo_viewpoints", ,
       RTAO(stereoViewpoints()),
       GROUP(code)
       SYNOPSIS("Return the number of viewpoints for the current display"))



// ============================================================================
//
//    Setting attributes
//
// ============================================================================

PREFIX(EnableDepthTest, boolean, "enable_depth_test",,
       RTAO(depthTest(self, true)),
       GROUP(code:graph)
       SYNOPSIS("Enable OpenGL depth test")
       DESCRIPTION("Activate the OpenGL depth test for polygons "
                   "using the depth buffer.")
       RETURNS(boolean, "The previous state of depth testing"))
PREFIX(DisableDepthTest, boolean, "disable_depth_test",,
       RTAO(depthTest(self, false)),
       GROUP(code:graph)
       SYNOPSIS("Disable OpenGL depth test")
       DESCRIPTION("Deactivate the OpenGL depth test for polygons.")
       RETURNS(boolean, "The previous state of depth testing"))
PREFIX(EnableDepthMask, boolean, "enable_depth_mask",,
       RTAO(depthMask(self, true)),
       GROUP(code:graph)
       SYNOPSIS("Enable OpenGL depth mask")
       DESCRIPTION("Equivalent to glEnable(GL_DEPTH_MASK)")
       RETURNS(boolean, "The previous state of depth mask"))
PREFIX(DisableDepthMask, boolean, "disable_depth_mask",,
       RTAO(depthMask(self, false)),
       GROUP(code:graph)
       SYNOPSIS("Disable OpenGL depth mask")
       DESCRIPTION("Equivalent to glEnable(GL_DEPTH_MASK)")
       RETURNS(boolean, "The previous state of depth mask"))
PREFIX(DepthFunction, boolean, "depth_function",
       PARM(func, text, ""),
       RTAO(depthFunction(self, func)),
       SYNOPSIS("Set the function for depth comparisons."))
PREFIX(BlendFunction, boolean, "blend_function",
       PARM(src, text, "")
       PARM(dst, text, ""),
       RTAO(blendFunction(self, src, dst)),
       SYNOPSIS("Set the blend function"))
PREFIX(BlendFunctionSeparate, boolean, "blend_function_separate",
       PARM(src, text, "")
       PARM(dst, text, "")
       PARM(srca, text, "")
       PARM(dsta, text, ""),
       RTAO(blendFunctionSeparate(self, src, dst, srca, dsta)),
       SYNOPSIS("Set the blend function separately for color and alpha"))
PREFIX(BlendEquation, boolean, "blend_equation",
       PARM(eq, text, ""),
       RTAO(blendEquation(self, eq)),
       SYNOPSIS("Set the blend function separately for color and alpha"))
PREFIX(Refresh, tree, "refresh",
       PARM(interval, real, "Interval in seconds"),
       RTAO(refresh(self, interval)),
       GROUP(code:graph)
       SYNOPSIS("Set document refresh time")
       DESCRIPTION("Refresh the document after the given time interval."))
PREFIX(RefreshOn, tree, "refresh_on",
       PARM(event_type, integer, "Type of event to monitor (Qt value)"),
       RTAO(refreshOn(self, event_type)),
       GROUP(events)
       SYNOPSIS("Refresh current layout on a specific event type")
       DESCRIPTION("Refresh the current layout when the application receives "
                   "the specified event type. Event type are integer values "
                   "defined by the QEvent::Type class "
                   "(http://doc.trolltech.com/4.6/qevent.html#Type-enum). "
                   "The following constants are predefined for the "
                   "most common event types:\n"
                   "TimerEvent                  = 1\n"
                   "MouseButtonPressEvent       = 2\n"
                   "MouseButtonReleaseEvent     = 3\n"
                   "MouseButtonDblClickEvent    = 4\n"
                   "MouseMoveEvent              = 5\n"
                   "KeyPressEvent               = 6\n"
                   "KeyReleaseEvent             = 7\n"))
PREFIX(NoRefreshOn, tree, "no_refresh_on",
       PARM(event_type, integer, "Type of event (Qt value)"),
       RTAO(noRefreshOn(self, event_type)),
       GROUP(events)
       SYNOPSIS("Do not refresh current layout on a specific event type")
       DESCRIPTION("Cancel refresh on specified event type, if it was set to refresh. "
                   "See refresh_on for a list of event type values."))
PREFIX(DefaultRefresh, tree, "default_refresh",
       PARM(interval, real, "Interval in seconds"),
       RTAO(defaultRefresh(self, interval)),
       GROUP(time:events)
       SYNOPSIS("Change default refresh interval for time primitives")
       DESCRIPTION("Set the documents refresh interval for code blocks that "
                   "depend on time due to the use of the time or "
                   "page_time primitive."))
PREFIX(DefaultRefreshGet, tree, "default_refresh",
       ,
       RTAO(defaultRefresh(self, -1.0)),
       GROUP(time:events)
       SYNOPSIS("Return the current value of the default refresh interval")
       DESCRIPTION("Get the document refresh interval for code blocks that "
                   "depend on time due to the use of the time or "
                   "page_time primitive."))
PREFIX(LastRefresh, real, "refresh_time",
       ,
       RTAO(refreshTime(self)),
       GROUP(time:events)
       SYNOPSIS("Return the time since the current layout was refreshed, or 0"))
PREFIX(PostEvent, tree, "post_event",
       PARM(event_type, integer, "Identifier of the user event to post"),
       RTAO(postEvent(event_type)),
       SYNOPSIS("Post a user event for the Tao widget."))
PREFIX(UserEvent, tree, "user_event",
       PARM(name, text, "An identifier for the event"),
       RTAO(registerUserEvent(name)),
       SYNOPSIS("Allocate a user event for use with post_event and refresh_on.")
       DESCRIPTION("Returns an available user event type. "
                   "The value returned for a given number is always the same. "
                   "It can be passed to post_event or refresh_on."))
#ifndef CFG_NOSRCEDIT
PREFIX(ShowSource, boolean, "show_source",
       PARM(flag, boolean, "Flag controlling whether source is shown"),
       RTAO(showSource(self, flag)),
       GROUP(gui)
       SYNOPSIS("Show or hide the source code panel")
       DESCRIPTION("Shows the source code panel when the flag is true, "
                   "hide it when it is false.")
       RETURNS(boolean,
               "The previous visibility state of the "
               "source code panel."))
#endif
PREFIX(FullScreen, boolean, "full_screen",
       PARM(flag, boolean, "Flag controlling full-screen mode"),
       RTAO(fullScreen(self, flag)),
       GROUP(gui)
       SYNOPSIS("Enter or exit full-screen mode for the document")
       DESCRIPTION("When the flag is true, display the document in "
                   "full-screen mode. When the flag is false, display the "
                   "document in a window.")
       RETURNS(boolean, "The previous full-screen state."))
PREFIX(ToggleFullScreen, boolean, "toggle_full_screen", ,
       RTAO(toggleFullScreen(self)),
       GROUP(gui)
       SYNOPSIS("Toggle full-screen mode")
       DESCRIPTION("Toggle document display mode between full-screen and "
                   "windowed mode.")
       RETURNS(boolean, "The previous full-screen state of the document."))
PREFIX(AutoHideCursor, boolean, "auto_hide_cursor",
       PARM(flag, boolean, "Flag controlling cursor hiding"),
       RTAO(autoHideCursor(self, flag)),
       GROUP(gui)
       SYNOPSIS("Control the automatic hiding of the cursor"))
PREFIX(ToggleAutoHideCursor, boolean, "toggle_auto_hide_cursor", ,
       RTAO(toggleAutoHideCursor(self)),
       GROUP(gui)
       SYNOPSIS("Toggle automatic hiding of the cursor"))
PREFIX(SlideShow, boolean, "slide_show",
       PARM(flag, boolean, "Flag controlling auto-hide mode"),
       RTAO(slideShow(self, flag)),
       GROUP(gui)
       SYNOPSIS("Control slide-show mode")
       DESCRIPTION("Activate or deactivate slide-show mode, depending on "
                   "the value of the flag. When activated, the document is "
                   "displayed full-screen, the cursor hides automatically "
                   "and the screensaver is deactivated.")
       RETURNS(boolean,
               "A flag indicating the previous value of the "
               "slide-show mode."))
PREFIX(ToggleSlideShow, boolean, "toggle_slide_show", ,
       RTAO(toggleSlideShow(self)),
       GROUP(gui)
       SYNOPSIS("Toggle slide-show mode"))
PREFIX(BlankScreen, boolean, "blank_screen",
       PARM(flag, boolean, "Flag controlling blank mode"),
       RTAO(blankScreen(self, flag)),
       GROUP(gui)
       SYNOPSIS("Blank screen or show presentation normally")
       DESCRIPTION("Activate or deactivate blank screen mode, depending on "
                   "the value of the flag. When activated, the screen is "
                   "blanked (no display).")
       RETURNS(boolean,
               "A flag indicating the previous value of the "
               "blank screen mode."))
PREFIX(ToggleBlankScreen, boolean, "toggle_blank_screen", ,
       RTAO(toggleBlankScreen(self)),
       GROUP(gui)
       SYNOPSIS("Toggle blank screen mode"))
PREFIX(StereoIdentify, boolean, "stereo_identify",
       PARM(flag, boolean, "Flag controlling stereo test pattern activation"),
       RTAO(stereoIdentify(self, flag)),
       GROUP(gui)
       SYNOPSIS("Show a stereoscopic test pattern or show presentation normally")
       DESCRIPTION("Activate or deactivate a test pattern, depending on "
                   "the value of the flag. When activated, the screen shows "
                   "different images for each viewpoint to assist in "
                   "troubleshooting stereoscopy problems.")
       RETURNS(boolean,
               "A flag indicating the previous value of the "
                "blank screen mode."))
PREFIX(ToggleStereoIdentify, boolean, "toggle_stereo_identify", ,
       RTAO(toggleStereoIdentify(self)),
       GROUP(gui)
       SYNOPSIS("Toggle stereo test pattern"))
PREFIX(ShowStatistics, boolean, "show_statistics",
       PARM(flag, boolean, "Flag controlling display of rendering statistics (fps)"),
       RTAO(showStatistics(self, flag)),
       GROUP(gui)
       SYNOPSIS("Control the display of rendering statistics"))
PREFIX(ToggleShowStatistics, boolean, "toggle_show_statistics", ,
       RTAO(toggleShowStatistics(self)),
       GROUP(gui)
       SYNOPSIS("Toggle display of rendering statistics"))
PREFIX(LogStatistics, boolean, "log_statistics",
       PARM(flag, boolean, "Flag controlling output of statistics to stdout"),
       RTAO(logStatistics(self, flag)),
       GROUP(gui)
       SYNOPSIS("Enable or disable logging of performance statistics")
       DESCRIPTION("When the flag is true, performance statistics are sent "
                   "periodically to standard output as CSV data.")
       RETURNS(boolean, "The previous state."))
PREFIX(ToggleLogStatistics, boolean, "toggle_log_statistics", ,
       RTAO(toggleLogStatistics(self)),
       GROUP(gui)
       SYNOPSIS("Toggle logging of performance statistics")
       DESCRIPTION("Toggle logging of performance statistics to stdout.")
       RETURNS(boolean, "The previous state."))
PREFIX(FrameCount, integer, "frame_count", ,
       RTAO(frameCount(self)),
       GROUP(gui)
       SYNOPSIS("The current value of the frame counter")
       DESCRIPTION("Returns the number of frames that have been displayed "
                   "so far for the current document.")
       RETURNS(integer, "The number of frames."))
PREFIX(ResetView, boolean, "reset_view", ,
       RTAO(resetViewAndRefresh(self)),
       GROUP(gui)
       SYNOPSIS("Reset document view to default parameters"))
PREFIX(PanEye, boolean, "pan",
       PARM(dx, real, "Displacement along the X axis")
       PARM(dy, real, "Displacementalong the Y axis"),
       RTAO(panView(self, dx, dy)),
       GROUP(gui)
       SYNOPSIS("Pan the document view"))
PREFIX(GetZoom, real, "zoom", ,
       RTAO(currentZoom(self)),
       GROUP(gui)
       SYNOPSIS("Get current level of zoom"))
PREFIX(SetZoom, boolean, "zoom",
       PARM(z, real, "Zoom factor"),
       RTAO(setZoom(self, z)),
       GROUP(gui)
       SYNOPSIS("Set current level of zoom"))
PREFIX(GetScaling, real, "camera_scaling", ,
       RTAO(currentScaling(self)),
       GROUP(gui:camera)
       SYNOPSIS("Get current camera scaling factor"))
PREFIX(SetScaling, boolean, "camera_scaling",
       PARM(scaling, real, "Scaling factor"),
       RTAO(setScaling(self, scaling)),
       GROUP(gui:camera)
       SYNOPSIS("Set the camera scaling factor"))
PREFIX(GetEye, infix, "camera_position", ,
       RTAO(currentCameraPosition(self)),
       GROUP(gui:camera)
       SYNOPSIS("Return the current position of the camera"))
PREFIX(SetEye, boolean, "camera_position",
       PARM(x, real, "X coordinate")
       PARM(y, real, "Y coordinate")
       PARM(z, real, "Z coordinate"),
       RTAO(setCameraPosition(self, x, y, z)),
       GROUP(gui:camera)
       SYNOPSIS("Set the camera position"))
PREFIX(GetCenter, infix, "camera_target", ,
       RTAO(currentCameraTarget(self)),
       GROUP(gui:camera)
       SYNOPSIS("Return the point the camera is looking at"))
PREFIX(SetCenter, boolean, "camera_target",
       PARM(x, real, "X coordinate")
       PARM(y, real, "Y coordinate")
       PARM(z, real, "Z coordinate"),
       RTAO(setCameraTarget(self, x, y, z)),
       GROUP(gui:camera)
       SYNOPSIS("Set the point the camera is looking at"))
PREFIX(GetCameraUp, infix, "camera_up_vector", ,
       RTAO(currentCameraUpVector(self)),
       GROUP(gui:camera)
       SYNOPSIS("Return the up direction for the camera"))
PREFIX(SetCameraUp, boolean, "camera_up_vector",
       PARM(x, real, "X component")
       PARM(y, real, "Y component")
       PARM(z, real, "Z component"),
       RTAO(setCameraUpVector(self, x, y, z)),
       GROUP(gui:camera)
       SYNOPSIS("Set the up direction for the camera"))
PREFIX(GetModelMatrix, infix, "model_matrix", ,
       RTAO(currentModelMatrix(self)),
       GROUP(gui)
       SYNOPSIS("Return the model matrix which convert from object space to world space"))
PREFIX(ToggleHandCursor, boolean, "toggle_hand_cursor", ,
       RTAO(toggleHandCursor(self)),
       GROUP(gui:camera)
       SYNOPSIS("Toggle between hand (panning) and arrow (moving) cursors"))
PREFIX(KeyboardModifiers, integer, "keyboard_modifiers", ,
       RTAO(lastModifiers(self)),
       GROUP(gui:keyboard)
       SYNOPSIS("Return the current keyboard modifiers")
       DESCRIPTION("The keyboard modifiers are a bitwise or "
                   "of the following values:\n"
                   "0x02000000	One of the Shift keys\n"
                   "0x04000000	One of the Ctrl / Control keys\n"
                   "0x08000000	One of the Alt keys\n"
                   "0x10000000	One of the Meta keys\n"
                   "0x20000000	A keypad button\n"
                   "0x40000000	Mode_switch key (X11 only)\n"
                   "\n"
                   "Note: On Mac OS X, the Control modifier corresponds to "
                   "the Command keys on the Macintosh keyboard, and the "
                   "Meta modifier corresponds to the Control keys. "
                   "The Keypad modifier will also be set when an arrow key "
                   "is pressed as the arrow keys are considered part of "
                   "the keypad.\n"
                   "Note: On Windows keyboards, the Meta modifier is mapped "
                   "to the optional Windows key.")
       RETURNS(integer, "The current modifiers"))
PREFIX(EnableAnimations,  boolean,  "enable_animations",
       PARM(an, boolean, "on or off"),
       RTAO(enableAnimations(self, an)),
       GROUP(gui)
       SYNOPSIS("Enable or disable animations")
       DESCRIPTION("Enable or disable animations")
       RETURNS(boolean, "True if previous state was on."))
PREFIX(SetDisplayFunction,  boolean,  "display_mode",
       PARM(name, text, "The name of the display mode"),
       RTAO(setDisplayMode(self, name)),
       SYNOPSIS("Select a display mode (2D, split stereoscopy, etc.)")
       RETURNS(boolean, "True on success."))
PREFIX(CurrentDisplayFunction,  text,  "display_mode",
       ,
       RTAO(displayMode()),
       SYNOPSIS("Return the name of the current display mode.")
       RETURNS(text, "The name of the current display mode."))
PREFIX(AddDisplayModeToMenu,  boolean,  "add_display_mode_to_menu",
       PARM(name, text, "The name of the display mode")
       PARM(label, text, "The name of the menu entry"),
       RTAO(addDisplayModeToMenu(self, name, label)),
       SYNOPSIS("Adds an entry for the display mode to the view menu")
       RETURNS(boolean, "True on success."))
PREFIX(EnableStereoscopy,  boolean,  "enable_stereoscopy",
       PARM(mode, symbol, "true or false or mode name"),
       RTAO(enableStereoscopy(self, mode)),
       GROUP(gui)
       SYNOPSIS("Enable or disable stereoscopie mode")
       DESCRIPTION("Enable or disable stereoscopie mode")
       RETURNS(boolean, "True if previous state was on."))
PREFIX(EnableStereoscopyText,  boolean,  "enable_stereoscopy",
       PARM(mode, text, "true or false or mode name"),
       RTAO(enableStereoscopyText(self, mode)),
       GROUP(gui)
       SYNOPSIS("Enable or disable stereoscopie mode")
       DESCRIPTION("Enable or disable stereoscopie mode")
       RETURNS(boolean, "True if previous state was on."))
PREFIX(EyeDistance,  boolean,  "eye_distance",
       PARM(e, real, ),
       RTAO(setEyeDistance(self, e)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(GetEyeDistance,  real,  "eye_distance", , RTAO(getEyeDistance(self)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(ZNear,  boolean,  "z_near",
       PARM(zn, real, ),
       RTAO(setZNear(self, zn)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(GetZNear,  real,  "z_near", , RTAO(getZNear(self)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(ZFar,  boolean,  "z_far",
       PARM(zf, real, ),
       RTAO(setZFar(self, zf)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(GetZFar,  real,  "z_far", , RTAO(getZFar(self)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(CameraToScreen,  boolean,  "camera_to_screen",
       PARM(d, real, ),
       RTAO(setCameraToScreen(self, d)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(GetCameraToScreen,  real,  "camera_to_screen", , RTAO(getCameraToScreen(self)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(PolygonOffset,  integer,  "polygon_offset",
       PARM(f0, real, "factor base")
       PARM(f1, real, "factor increment")
       PARM(u0, real, "unit base")
       PARM(u1, real, "unit increment"),
       RTAO(polygonOffset(self, f0, f1, u0, u1)),
       GROUP(graph)
       SYNOPSIS("Set the polygon offset factors")
       DESCRIPTION("Set the polygon offset factors")
       RETURNS(integer, "the current polygon offset"))
PREFIX(EnableVSync,  boolean,  "enable_vsync",
       PARM(an, boolean, "on or off"),
       RTAO(enableVSync(self, an)),
       GROUP()
       SYNOPSIS("Enable or disable VSync")
       DESCRIPTION("Enable or disable VSynx. Enabling VSync prevents tearing, at the price of a lower framerate.")
       RETURNS(boolean, "True if previous state was on."))



// ============================================================================
//
//   Frames and widgets
//
// ============================================================================

PREFIX(Caption,  tree,  "status",
       PARM(t, text, "The text for the status line.")
       PARM(tm, real, "Display duration in seconds."),
       RTAO(status(self, t, tm)),
       GROUP(gui)
       SYNOPSIS("Set the status line of the window")
       DESCRIPTION("Set the content of the status line of the window"))
PREFIX(LinearGradient,  tree,  "linear_gradient",
       PARM(start_x, real, "x-coordinate of the gradient start")
       PARM(start_y, real, "y-coordinate of the gradient start")
       PARM(end_x, real, "x-coordinate of the gradient end")
       PARM(end_y, real, "y-coordinate of the gradient end")
       PARM(w, real, "width")
       PARM(h, real, "height")
       PARM(p, code, "The program that allow to define colors for the gradient"),
       RTAO(linearGradient(context, self, start_x, start_y, end_x, end_y, w, h, p)),
       GROUP(widget)
       SYNOPSIS("A linear gradient with content as colors")
       DESCRIPTION("Make a linear gradient")
       RETURNS(tree, "The id of current gradient"))
PREFIX(RadialGradient,  tree,  "radial_gradient",
       PARM(center_x, real, "x-coordinate of the gradient center")
       PARM(center_y, real, "y-coordinate of the gradient center")
       PARM(radius, real, "gradient radius")
       PARM(w, real, "width")
       PARM(h, real, "height")
       PARM(p, code, "The program that allow to define colors for the gradient"),
       RTAO(radialGradient(context, self, center_x, center_y, radius, w, h, p)),
       GROUP(widget)
       SYNOPSIS("A radial gradient with content as colors")
       DESCRIPTION("Make a radial gradient")
       RETURNS(tree, "The id of current gradient"))
PREFIX(ConicalGradient,  tree,  "conical_gradient",
       PARM(center_x, real, "x-coordinate of the gradient center")
       PARM(center_y, real, "y-coordinate of the gradient center")
       PARM(angle, real, "gradient angle")
       PARM(w, real, "width")
       PARM(h, real, "height")
       PARM(p, code, "The program that allow to define colors for the gradient"),
       RTAO(conicalGradient(context, self, center_x, center_y, angle, w, h, p)),
       GROUP(widget)
       SYNOPSIS("A conical gradient with content as colors")
       DESCRIPTION("Make a conical gradient")
       RETURNS(tree, "The id of current gradient"))
// ============================================================================
//
//    Menus
//
// ============================================================================

PREFIX(Menu,  tree,  "menu",
       PARM(n, text, "Name that uniquely identify this menu")
       PARM(lbl, text, "The label of the menu")
       PARM(icon, text, "The name of the icon (filename)."),
       RTAO(menu(self, n, lbl, icon, false)),
       GROUP(widget:menu)
       SYNOPSIS("Create/Select a menu")
       DESCRIPTION("Add the menu to the current menu bar or create the contextual menu. If the menu already exist, it is updated and set as the current menu"))

PREFIX(SubMenu,  tree,  "submenu",
       PARM(name, text, "Name that uniquely identify this menu")
       PARM(lbl, text, "The label of the menu")
       PARM(icon, text, "The name of the icon (filename)."),
       RTAO(menu(self, name, lbl, icon, true)),
       GROUP(widget:menu)
       SYNOPSIS("Create/Select a submenu")
       DESCRIPTION("Add the submenu to the current menu. If the submenu already exist, it is updated and set as the current menu"))

PREFIX(MenuItem,  tree,  "menu_item",
       PARM(n, text, "Name that uniquely identify this entry")
       PARM(lbl, text, "The label of the entry")
       PARM(icon, text, "The name of the icon (filename).")
       PARM(cable, boolean, "Should this entry carry a check box ?")
       PARM(isc, text, "If this entry carries a check box, is it cheked or not.")
       PARM(t, code, "The command to execute on item selection."),
       RTAO(menuItem(self, n, lbl, icon, cable, isc, t)),
       GROUP(widget:menu)
       SYNOPSIS("add an entry in a menu")
       DESCRIPTION("Add an entry in the current menu with the label, icon, checkmark and command."))

PREFIX(MenuItemEnable,  tree,  "menu_item_enable",
       PARM(n, text, "Name that identify the menu to enable/disable")
       PARM(enable, boolean, "The status of the menu"),
       RTAO(menuItemEnable(self, n, enable)),
       GROUP(widget:menu)
       SYNOPSIS("enable or disable a menu item")
       DESCRIPTION("Enable or disable a menu item."))

PREFIX(ToolBar,  tree,  "toolbar",
       PARM(name, text, "Name that uniquely identify this toolbar")
       PARM(lbl, text, "The label of the toolbar")
       PARM(loc, text, "The location of the toolbar in the widget. Supported values are [n|N]*, [e|E]*, [s|S]*, [w|W|o|O]*"),
       RTAO(toolBar(self, name, lbl, true, loc)),
       GROUP(widget:menu)
       SYNOPSIS("Add the toolBar")
       DESCRIPTION("Add the toolBar to the current widget at the specify location."))

PREFIX(MenuBar,  tree,  "menubar", , RTAO(menuBar(self)),
       GROUP(widget:menu)
       SYNOPSIS("Set the current menubar")
       DESCRIPTION("Set the current menubar to the default menuBar"))

PREFIX(Separator,  tree,  "separator", , RTAO(separator(self)),
       GROUP(widget:menu)
       SYNOPSIS("Add a separator")
       DESCRIPTION("Add a separator to the current menu or menu bar or tool bar. "))


// ============================================================================
//
//   Error management
//
// ============================================================================

PREFIX(ErrorMessage,  tree,  "error",
       PARM(m, text, )
       PARM(s, tree, )
       , return Tao::Widget::runtimeError(self, m, s),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(ErrorMessage0,  tree,  "error",
       PARM(m, text, "The message to display")
       , return Tao::Widget::runtimeError(self, m, NULL),
       GROUP()
       SYNOPSIS("Display an error message from the input")
       DESCRIPTION("Display an error message from the input")
       RETURNS(tree, "[TODO]"))



// ============================================================================
//
//   Tree management
//
// ============================================================================

PREFIX(Insert0,  boolean,  "insert",
       PARM(m, text, )
       PARM(t, tree, ),
       RTAO(insert(self, t, m)),
       GROUP()
       SYNOPSIS("")
       DESCRIPTION(""))
PREFIX(Insert,  boolean,  "insert",
       PARM(t, tree, "message used to mark the change in the version management tool (git). "),
       RTAO(insert(self, t)),
       GROUP(tree)
       SYNOPSIS("Insert code")
       DESCRIPTION("Insert at the end of page or program"))
PREFIX(Delete,  boolean,  "delete_selection",
       PARM(k, text, "key [TODO]"),
       RTAO(deleteSelection(self, k)),
       GROUP(tree)
       SYNOPSIS("Delete the selection")
       DESCRIPTION("Delete the selection (with text support)"))
PREFIX(SetAttribute,  boolean,  "set_attribute",
       PARM(n, text, "Attribute name")
       PARM(t, tree, "Attribute value "),
       RTAO(setAttribute(self, n, t, "group,shape")),
       GROUP(tree)
       SYNOPSIS("set attribute is selection")
       DESCRIPTION("Insert the tree in all shapes in the selection"))



// ============================================================================
//
//   z order management
//
// ============================================================================

PREFIX(BringToFront,  boolean,  "bring_to_front", , RTAO(bringToFront(self)),
       GROUP(code:zorder)
       SYNOPSIS("Bring the selected shape to front")
       DESCRIPTION("Bring the selected shape to front. This moves the source code of the selection to the end of the page or program"))
PREFIX(BringForward,  boolean,  "bring_forward", , RTAO(bringForward(self)),
       GROUP(code:zorder)
       SYNOPSIS("Bring the selection one forward")
       DESCRIPTION("Swap the selected shape and the one in front of it. This is done by swaping code in the source."))
PREFIX(SendToBack,  boolean,  "send_to_back", , RTAO(sendToBack(self)),
       GROUP(code:zorder)
       SYNOPSIS("Send the selected shape to back")
       DESCRIPTION("Send the selected shape to back. This moves the source code of the selection to the begining of the page or program"))
PREFIX(SendBackward,  boolean,  "send_backward", , RTAO(sendBackward(self)),
       GROUP(code:zorder)
       SYNOPSIS("Send the selection one backward")
       DESCRIPTION("Swap the selected shape and the one just behind it. This is done by swaping code in the source."))



// ============================================================================
//
//   group management
//
// ============================================================================

PREFIX(Group,  tree,  "group",
       PARM(t, code, "The code to group"),
       RTAO(group(context, self, t)),
       GROUP(code:group)
       SYNOPSIS("Create a logical group")
       DESCRIPTION("Group objects together, make them selectable as a whole."))
PREFIX(GroupSelection,  boolean,  "group_selection", ,
       RTAO(groupSelection(self)),
       GROUP(code:group)
       SYNOPSIS("Create the group from the selected objects")
       DESCRIPTION("Modify the source code to group the selection."))
PREFIX(UngroupSelection,  boolean,  "ungroup_selection", ,
       RTAO(ungroupSelection(self)),
       GROUP(code:group)
       SYNOPSIS("ungroup the selected group")
       DESCRIPTION("Modify the source code to ungroup the selection"))



// ============================================================================
//
//   Unit conversions
//
// ============================================================================

POSTFIX(FromCm,    real,
        PARM(x, real, "The value in cm")
        ,  "cm", RTAO(fromCm(self, x)),
        GROUP(code:unit)
        SYNOPSIS("Convert from cm to pixels")
        DESCRIPTION("Convert from cm to pixels")
        RETURNS(real, "The value in pixel. "))
POSTFIX(FromMm,    real,
        PARM(x, real, "The value in mm")
        ,  "mm", RTAO(fromMm(self, x)),
        GROUP(code:unit)
        SYNOPSIS("Convert from mm to pixels")
        DESCRIPTION("Convert from mm to pixels")
        RETURNS(real, "The value in pixel. "))
POSTFIX(FromInch,  real,
        PARM(x, real, "The value in inch")
        ,  "inch", RTAO(fromIn(self, x)),
        GROUP(code:unit)
        SYNOPSIS("Convert from inch to pixels")
        DESCRIPTION("Convert from inch to pixels")
        RETURNS(real, "The value in pixel. "))
POSTFIX(FromPt,    real,
        PARM(x, real, "The value in point")
        ,  "pt", RTAO(fromPt(self, x)),
        GROUP(code:unit)
        SYNOPSIS("Convert from pt to pixels")
        DESCRIPTION("Convert from pt to pixels")
        RETURNS(real, "The value in pixel. "))
POSTFIX(FromPx,    real,
        PARM(x, real, "The value in pixel")
        ,  "px", RTAO(fromPx(self, x)),
        GROUP(code:unit)
        SYNOPSIS("Convert from pixel")
        DESCRIPTION("Convert from pixel (currently 1-1 mappingcould be based on scaling?)")
        RETURNS(real, "The value in pixel. "))



// ============================================================================
//
//   Misc...
//
// ============================================================================

PREFIX(Constant,  tree,  "constant",
       PARM(t, tree, "the tree that is constant"),
       RTAO(constant(self, t)),
       GROUP(code)
       SYNOPSIS("a constant tree")
       DESCRIPTION("A tree that cannot be modify.")
       RETURNS(tree, "the tree"))

PREFIX(Exit, integer, "exit",
       PARM(n, integer, "exit parameter"), exit(n.value);,
       GROUP(code)
       SYNOPSIS("Exit from Tao")
       DESCRIPTION("Exit from Tao with the given value"))

PREFIX(GenDoc,  text,  "generate_doc",
       PARM(t, tree, "The tree from wich extracting the documentation"),
       RTAO(generateDoc(self, t, "XL")),
       GROUP(documentation)
       SYNOPSIS("generate the doc for the specified tree ")
       DESCRIPTION("Extract the documentation from the specified tree. ")
       RETURNS(text, "The Text contains the documentation, ready to be parsed. "))

PREFIX(GenAllDoc,  tree,  "generate_all_doc",
       PARM(filename, text, "File name for the documentation"),
       RTAO(generateAllDoc(self, filename)),
       GROUP(documentation)
       SYNOPSIS("Generate all the documentation. ")
       DESCRIPTION("Extract the documentation from the context, "
                   "the primitive and the current document. "
                   "It writes the documentation into the specified files "
                   "if any. ")
       RETURNS(tree,
               "The Text contains the documentation, "
               "ready to be parsed. "))
PREFIX(ListFiles2, tree, "files", PARM(pat, tree, ""),
       RTAO(listFiles(context, self, pat)),
       GROUP(misc)
       SYNOPSIS("")
       DESCRIPTION("List regular files that match pattern. Examples of valid patterns: '*.jpg' '*/*.jpg' '/Users/john/*.jpg' '*.[jJ][pP][gG]'")
       RETURNS(tree, ""))
PREFIX(ListFiles3, tree, "list_files", PARM(pat, tree, ""),
       RTAO(listFiles(context, self, pat)),
       GROUP(misc)
       SYNOPSIS("")
       DESCRIPTION("List regular files that match pattern. Examples of valid patterns: '*.jpg' '*/*.jpg' '/Users/john/*.jpg' '*.[jJ][pP][gG]'")
       RETURNS(tree, ""))
PREFIX(TrAdd,  text,  "tr",
       PARM(from, text, "The english string")
       PARM(to, text, "The translation"),
       RTAO(xlTrAdd(self, from, to)),
       GROUP(i18n)
       SYNOPSIS("Add a translation into the translation map"))
PREFIX(Tr,  text,  "tr",
       PARM(t, text, "The string to translate"),
       RTAO(xlTr(self, t)),
       GROUP(i18n)
       SYNOPSIS("Translate a string into the current language")
       RETURNS(text, "The translated text."))
PREFIX(isReadOnly,  tree,  "is_read_only",,
       RTAO(readOnly()),
       GROUP(misc)
       SYNOPSIS("Check if document is read only")
       RETURNS(tree, ""))
PREFIX(BaseName,  tree,  "base_name",
       PARM(f, text, "filename"),
       RTAO(baseName(self, f)),
       GROUP(misc)
       SYNOPSIS("Returns the base name of a file without the path.")
       RETURNS(tree, ""))
PREFIX(DirName,  tree,  "dir_name",
       PARM(f, text, "filename"),
       RTAO(dirName(self, f)),
       GROUP(misc)
       SYNOPSIS("Returns the path of the specified filename.")
       RETURNS(tree, ""))
PREFIX(OpenUrl, boolean,  "open_url",
       PARM(u, text, "URL"),
       RTAO(openUrl(self, u)),
       GROUP(misc)
       SYNOPSIS("Opens the given URL with the appropriate application.")
       RETURNS(boolean, ""))



// ============================================================================
//
//   Module management
//
// ============================================================================

// May hide primitive: import "filename" (from xlr/basics.tbl)
// Not a problem because implementation takes care of the above syntax
PREFIX(ImportModule, tree, "import",
       PARM(m, tree, "Module file name"),
       return Tao::ModuleManager::import(context, self, m, true),
       GROUP(modules)
       SYNOPSIS("Import a module from a file"))
PREFIX(Blink, boolean,  "blink",
       PARM(on, real, "Duration of first period, primitive returns true")
       PARM(off, real, "Duration of second period, primitive returns false")
       PARM(after, real, "Start blinking only 'after' seconds after "
                         "application startup"),
       RTAO(blink(self, on, off, after)),)
PREFIX(HasLicense, boolean,  "has_license",
       PARM(feature, text, "The feature name to check"),
       RTAO(hasLicense(self, feature)),)
PREFIX(CheckLicense, boolean,  "check_license",
       PARM(feature, text, "The feature name to check")
       PARM(critical, boolean, "Show warning (false) or error (true) dialog on no license?"),
       RTAO(checkLicense(self, feature, critical)),)
PREFIX(CheckImpressOrLicense, boolean,  "check_impress_or_license",
       PARM(feature, text, "The feature name to check"),
       RTAO(checkImpressOrLicense(self, feature)),)
// Texture cache
PREFIX(TextureMipmap, boolean, "texture_mipmap",
       PARM(enable, boolean, "Enable or disable"),
       return Tao::TextureCache::textureMipmap(enable),
       SYNOPSIS("Enable or disable mimmap generation for textures")
       DESCRIPTION("Controls whether mipmaps are created or not when a texture "
                   "file is loaded. Changing this setting does not cause "
                   "existing textures to be re-created."))
PREFIX(TextureCompress, boolean, "texture_compress",
       PARM(enable, boolean, "Enable or disable"),
       return Tao::TextureCache::textureCompress(enable),
       SYNOPSIS("Enable or disable use of compressed textures"))
PREFIX(TextureSaveCompressed, boolean, "texture_save_compressed",
       PARM(enable, boolean, "Enable or disable"),
       return Tao::TextureCache::textureSaveCompressed(enable),
       SYNOPSIS("Enable or disable creation of compressed texture files"))
PREFIX(TextureCacheMemSize, integer, "texture_cache_mem_size",
       PARM(bytes, integer, "The size of the texture cache in main memory"),
       return Tao::TextureCache::textureCacheMemSize(bytes),
       SYNOPSIS("Set the size of the texture cache (main memory)")
       DESCRIPTION("Defines the maximum amount of main memory that may be "
                   "used to keep textures as they are loaded from disk."))
PREFIX(TextureCacheGLSize, integer, "texture_cache_gl_size",
       PARM(bytes, integer, "The size of the texture cache in GL memory"),
       return Tao::TextureCache::textureCacheGLSize(bytes),
       SYNOPSIS("Set the size of the texture cache (GL memory)")
       DESCRIPTION("Defines the maximum amount of GL memory that may be "
                   "used to keep textures as they are loaded from disk."))
